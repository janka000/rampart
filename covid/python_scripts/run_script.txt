POCITACNIE BAZ:
python3 <path to count_observed_counts.py> <references.fasta> <.bam file> <rampart csv> -o <output file>

script vyrobi jeden vystupny subor, obsahujuci riadok
[pozicia, barcode, pocet A, C, G, T]
pre kazdu dvojicu (pozicia, barkod)

example - annotations/base_count/
python3 ../../python_scripts/count_observed_counts.py ../../protocols_nanocrop/references.fasta ../bam_files/fastq_runid_784dc821cafb065267ca1e03068a1a6a9b3d589d_0_0.bam ../fastq_runid_784dc821cafb065267ca1e03068a1a6a9b3d589d_0_0.csv -o bases_fastq_runid_784dc821cafb065267ca1e03068a1a6a9b3d589d_0_0.csv

SPAJANIE SUBOROV
python3 <path to merge_dir.py> <directory with csv files to be merged> <reference.fasta> <output file>

spoji .csv subory vytvorene Askarovym scriptom do jedneho

example - annotations/base_count/
python3 ../../python_scripts/merge_dir.py ./ ../../protocols_nanocrop/references.fasta ./csv.merged


be careful - ak output file konci .csv a bol by v tom istom priecinku, v ktorom boli povodne subory, nastane problem (pri dalsom spracovani toho isteho priecinku by script spokojne pripocital aj bazy z merged suboru a nasledne by ho prepisal - co je nenapadne, lebo ziadny novy subor pri tom nevznikne...)
	riesenie: spustat vzdy nad nejakymi sub-foldrami s mensim mnozstvom dat ALEBO priebezne mazat stare .csv (tie vytvorene askarovym skriptom) po tom, co ich pripocitame do velkeho spolocneho suboru. 
	
POROVNAVANIE MUTACII:
python3 <path to compare_mutations.py> <csv created by count_observed_counts.py> <references.fasta> <mut.txt> -o <output file>

spustenie v annotations/test/
python3 ../../python_scripts/compare_mutations.py ../base_count_new/csv.merged  ../../protocols_nanocrop/references.fasta ../../python_scripts/mut.txt -o test.txt

